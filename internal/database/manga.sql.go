// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: manga.sql

package database

import (
	"context"
	"database/sql"
)

const deleteManga = `-- name: DeleteManga :exec
DELETE FROM manga WHERE id = ?
`

func (q *Queries) DeleteManga(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteManga, id)
	return err
}

const getManga = `-- name: GetManga :one
SELECT id, title, slug, source, source_id, url, cover_url, cover_path, description, status, author, artist, genres, tags, anilist_id, mal_id, update_interval, auto_download, created_at, updated_at, last_checked_at FROM manga WHERE id = ? LIMIT 1
`

func (q *Queries) GetManga(ctx context.Context, id int64) (*Manga, error) {
	row := q.db.QueryRowContext(ctx, getManga, id)
	var i Manga
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Source,
		&i.SourceID,
		&i.Url,
		&i.CoverUrl,
		&i.CoverPath,
		&i.Description,
		&i.Status,
		&i.Author,
		&i.Artist,
		&i.Genres,
		&i.Tags,
		&i.AnilistID,
		&i.MalID,
		&i.UpdateInterval,
		&i.AutoDownload,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastCheckedAt,
	)
	return &i, err
}

const getMangaBySlug = `-- name: GetMangaBySlug :one
SELECT id, title, slug, source, source_id, url, cover_url, cover_path, description, status, author, artist, genres, tags, anilist_id, mal_id, update_interval, auto_download, created_at, updated_at, last_checked_at FROM manga WHERE slug = ? LIMIT 1
`

func (q *Queries) GetMangaBySlug(ctx context.Context, slug string) (*Manga, error) {
	row := q.db.QueryRowContext(ctx, getMangaBySlug, slug)
	var i Manga
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Source,
		&i.SourceID,
		&i.Url,
		&i.CoverUrl,
		&i.CoverPath,
		&i.Description,
		&i.Status,
		&i.Author,
		&i.Artist,
		&i.Genres,
		&i.Tags,
		&i.AnilistID,
		&i.MalID,
		&i.UpdateInterval,
		&i.AutoDownload,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastCheckedAt,
	)
	return &i, err
}

const getMangaForUpdate = `-- name: GetMangaForUpdate :many
SELECT id, title, slug, source, source_id, url, cover_url, cover_path, description, status, author, artist, genres, tags, anilist_id, mal_id, update_interval, auto_download, created_at, updated_at, last_checked_at FROM manga
WHERE auto_download = 1
  AND (last_checked_at IS NULL OR last_checked_at < datetime('now', '-1 hour'))
ORDER BY last_checked_at ASC
LIMIT ?
`

func (q *Queries) GetMangaForUpdate(ctx context.Context, limit int64) ([]*Manga, error) {
	rows, err := q.db.QueryContext(ctx, getMangaForUpdate, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Manga{}
	for rows.Next() {
		var i Manga
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Source,
			&i.SourceID,
			&i.Url,
			&i.CoverUrl,
			&i.CoverPath,
			&i.Description,
			&i.Status,
			&i.Author,
			&i.Artist,
			&i.Genres,
			&i.Tags,
			&i.AnilistID,
			&i.MalID,
			&i.UpdateInterval,
			&i.AutoDownload,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastCheckedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertManga = `-- name: InsertManga :one
INSERT INTO manga (
    title, slug, source, source_id, url, cover_url, description,
    status, author, artist, genres, tags
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, title, slug, source, source_id, url, cover_url, cover_path, description, status, author, artist, genres, tags, anilist_id, mal_id, update_interval, auto_download, created_at, updated_at, last_checked_at
`

type InsertMangaParams struct {
	Title       string         `json:"title"`
	Slug        string         `json:"slug"`
	Source      string         `json:"source"`
	SourceID    string         `json:"source_id"`
	Url         string         `json:"url"`
	CoverUrl    sql.NullString `json:"cover_url"`
	Description sql.NullString `json:"description"`
	Status      sql.NullString `json:"status"`
	Author      sql.NullString `json:"author"`
	Artist      sql.NullString `json:"artist"`
	Genres      sql.NullString `json:"genres"`
	Tags        sql.NullString `json:"tags"`
}

func (q *Queries) InsertManga(ctx context.Context, arg InsertMangaParams) (*Manga, error) {
	row := q.db.QueryRowContext(ctx, insertManga,
		arg.Title,
		arg.Slug,
		arg.Source,
		arg.SourceID,
		arg.Url,
		arg.CoverUrl,
		arg.Description,
		arg.Status,
		arg.Author,
		arg.Artist,
		arg.Genres,
		arg.Tags,
	)
	var i Manga
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Source,
		&i.SourceID,
		&i.Url,
		&i.CoverUrl,
		&i.CoverPath,
		&i.Description,
		&i.Status,
		&i.Author,
		&i.Artist,
		&i.Genres,
		&i.Tags,
		&i.AnilistID,
		&i.MalID,
		&i.UpdateInterval,
		&i.AutoDownload,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastCheckedAt,
	)
	return &i, err
}

const listManga = `-- name: ListManga :many
SELECT id, title, slug, source, source_id, url, cover_url, cover_path, description, status, author, artist, genres, tags, anilist_id, mal_id, update_interval, auto_download, created_at, updated_at, last_checked_at FROM manga ORDER BY title ASC
`

func (q *Queries) ListManga(ctx context.Context) ([]*Manga, error) {
	rows, err := q.db.QueryContext(ctx, listManga)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Manga{}
	for rows.Next() {
		var i Manga
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Source,
			&i.SourceID,
			&i.Url,
			&i.CoverUrl,
			&i.CoverPath,
			&i.Description,
			&i.Status,
			&i.Author,
			&i.Artist,
			&i.Genres,
			&i.Tags,
			&i.AnilistID,
			&i.MalID,
			&i.UpdateInterval,
			&i.AutoDownload,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastCheckedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMangaWithUnread = `-- name: ListMangaWithUnread :many
SELECT
    m.id, m.title, m.slug, m.source, m.source_id, m.url, m.cover_url, m.cover_path, m.description, m.status, m.author, m.artist, m.genres, m.tags, m.anilist_id, m.mal_id, m.update_interval, m.auto_download, m.created_at, m.updated_at, m.last_checked_at,
    SUM(CASE WHEN c.is_read = 0 AND c.status = 'completed' THEN 1 ELSE 0 END) AS unread_count
FROM manga m
LEFT JOIN chapter c ON c.manga_id = m.id
GROUP BY m.id
ORDER BY m.title ASC
`

type ListMangaWithUnreadRow struct {
	ID             int64           `json:"id"`
	Title          string          `json:"title"`
	Slug           string          `json:"slug"`
	Source         string          `json:"source"`
	SourceID       string          `json:"source_id"`
	Url            string          `json:"url"`
	CoverUrl       sql.NullString  `json:"cover_url"`
	CoverPath      sql.NullString  `json:"cover_path"`
	Description    sql.NullString  `json:"description"`
	Status         sql.NullString  `json:"status"`
	Author         sql.NullString  `json:"author"`
	Artist         sql.NullString  `json:"artist"`
	Genres         sql.NullString  `json:"genres"`
	Tags           sql.NullString  `json:"tags"`
	AnilistID      sql.NullInt64   `json:"anilist_id"`
	MalID          sql.NullInt64   `json:"mal_id"`
	UpdateInterval sql.NullString  `json:"update_interval"`
	AutoDownload   sql.NullInt64   `json:"auto_download"`
	CreatedAt      sql.NullString  `json:"created_at"`
	UpdatedAt      sql.NullString  `json:"updated_at"`
	LastCheckedAt  sql.NullString  `json:"last_checked_at"`
	UnreadCount    sql.NullFloat64 `json:"unread_count"`
}

func (q *Queries) ListMangaWithUnread(ctx context.Context) ([]*ListMangaWithUnreadRow, error) {
	rows, err := q.db.QueryContext(ctx, listMangaWithUnread)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListMangaWithUnreadRow{}
	for rows.Next() {
		var i ListMangaWithUnreadRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Source,
			&i.SourceID,
			&i.Url,
			&i.CoverUrl,
			&i.CoverPath,
			&i.Description,
			&i.Status,
			&i.Author,
			&i.Artist,
			&i.Genres,
			&i.Tags,
			&i.AnilistID,
			&i.MalID,
			&i.UpdateInterval,
			&i.AutoDownload,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastCheckedAt,
			&i.UnreadCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateManga = `-- name: UpdateManga :one
UPDATE manga SET
    title = ?,
    cover_url = ?,
    cover_path = ?,
    description = ?,
    status = ?,
    author = ?,
    artist = ?,
    genres = ?,
    tags = ?,
    anilist_id = ?,
    last_checked_at = datetime('now')
WHERE id = ?
RETURNING id, title, slug, source, source_id, url, cover_url, cover_path, description, status, author, artist, genres, tags, anilist_id, mal_id, update_interval, auto_download, created_at, updated_at, last_checked_at
`

type UpdateMangaParams struct {
	Title       string         `json:"title"`
	CoverUrl    sql.NullString `json:"cover_url"`
	CoverPath   sql.NullString `json:"cover_path"`
	Description sql.NullString `json:"description"`
	Status      sql.NullString `json:"status"`
	Author      sql.NullString `json:"author"`
	Artist      sql.NullString `json:"artist"`
	Genres      sql.NullString `json:"genres"`
	Tags        sql.NullString `json:"tags"`
	AnilistID   sql.NullInt64  `json:"anilist_id"`
	ID          int64          `json:"id"`
}

func (q *Queries) UpdateManga(ctx context.Context, arg UpdateMangaParams) (*Manga, error) {
	row := q.db.QueryRowContext(ctx, updateManga,
		arg.Title,
		arg.CoverUrl,
		arg.CoverPath,
		arg.Description,
		arg.Status,
		arg.Author,
		arg.Artist,
		arg.Genres,
		arg.Tags,
		arg.AnilistID,
		arg.ID,
	)
	var i Manga
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Source,
		&i.SourceID,
		&i.Url,
		&i.CoverUrl,
		&i.CoverPath,
		&i.Description,
		&i.Status,
		&i.Author,
		&i.Artist,
		&i.Genres,
		&i.Tags,
		&i.AnilistID,
		&i.MalID,
		&i.UpdateInterval,
		&i.AutoDownload,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastCheckedAt,
	)
	return &i, err
}
